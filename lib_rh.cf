bundle agent rh_add_interface_routes(interface, routes) {
# Expects string, array
# vars:
#    "management[172.18.43.0/24]"
#        string => "172.18.43.0/24 via 10.124.4.254",
#        comment => "Needed for communicating with monitoring cluster";
#
#    "management[10.119.156.0/26]"
#        string => "10.119.156.0/26 via 10.124.4.254",
#        comment => "Needed for talking to management interfaces on legacy
#                   network";
# methods:
#    "any" usebundle => rh_add_routes("bond2", "main.management");
#
    classes:
        "supported_os" or => { "centos_5", "redhat_5" };

    vars:
        "route_file"  string => "/etc/sysconfig/network-scripts/route-$(interface)";
        "route_index" slist => getindices("$(routes)");

    files:
        (centos_5|redhat_5)::
            "$(route_file)"
                comment     => "Ensure routes are added properly",
                create      => "true",
                perms       => mog("644", "root", "root"),
                edit_line   => append_if_no_line("$($(this.routes)[$(route_index)])"),
                classes     => if_repaired("route_add_restart_network");

    commands:
        route_add_restart_network::
            "/etc/init.d/network restart",
                ifvarclass => "centos_5|redhat_5";

    reports:
        !supported_os::
            "Sorry I don't know how to work with this OS";

}

bundle agent create_update_yum_repo(path) {
# Creates repomd (xml-rpm-metadata) repository 
# Updates metadata if any packages are added changed or removed
# Expects full path to repository directory
#    vars:
#        "updates_repo" string => "/var/repo_mirror/updates";
#
#    methods:
#        "supplemental_repo" usebundle => create_update_yum_repo("/var/repo_mirror/supplemental");
#        "updates_repo" usebundle => create_update_yum_repo("$(updates)");


    files:
        "$(path)/."
            create => "true",
            perms  => mog("755", "root", "root"),
            comment => "Ensure repository root directory exists";

        # Only check 1 level deep otherwise you will be detecting the change in the metadata itself as well.
        # That in turn will lead to an execution of creatrepo --update each time.
        "$(path)"
            changes         => detect_content,
            depth_search    => recurse("1"),
            classes         => if_repaired("update_repo_metadata"),
            comment         => "If any changes are detected we need to signal to update the metadata";

    classes:
        "repo_exists"    expression => fileexists("$(path)/repodata/repomd.xml"),
            comment => "Check if a repo exists yet";


    commands:
        "/usr/bin/createrepo $(path)"
            ifvarclass => not("repo_exists"),
            comment => "Create repository if one does not exist";

        # We only want to update the repo once per run. The metadata has not 
        # yet been updated. Update it and signal that it has been updated if 
        # the command returns zero.
        !(repo_metadata_updated)::
        "/usr/bin/createrepo --update $(path)"
            ifvarclass => "update_repo_metadata",
            classes    => if_repaired("repo_metadata_updated"),
            comment    => "We need to update the metadata since a change was detected, but only once per run";


}

bundle agent set_selinux_disabled {
# This bundle disables selinux
# If its currently enabled, it disables it
# It makes sure that it is configured to be disabled on next boot (via config file)
# Note: If enabled currently this just sets it to permissive, so you will have
#       extra logging until the next reboot.
#
    vars:
        "config[SELINUX]"   string  => "disabled";

        # If neither one of these is set, its the first pass, we only need to set this variable once
        !(selinux_disabled|selinux_needs_disabled)::
            "selinux_status"
                string => execresult("/usr/sbin/getenforce", "noshell"),
                policy => "overridable";

    classes:
        "selinux_disabled"  expression => regcmp("Permissive|Disabled", "$(selinux_status)");

        "selinux_needs_disabled" not => "selinux_disabled";
            

    commands:
        # Only set it once
        # If its not disabled, but needs disabled do it and raise a class
        !selinux_disabled::
            "/usr/sbin/setenforce 0"
                classes => "selinux_disabled",
                ifvarclass  => "selinux_needs_disabled",
                comment     => "Disable selinux, it causes issues without proper security
                                contexts and sadly no one wants to spend time on that";
    files:
        "/etc/selinux/config"
            edit_line => set_variable_values2("$(this.promiser)", "set_selinux_disabled.config"),
            comment     => "Make disable persistent across reboot";
}

bundle agent config_yum_client_repos(config){
# Expects array with yum repo configurations
#   vars:
#       "setrepo[repositoryid][name]"                string => "RedHat 5 Updates";
#       "setrepo[repositoryid][baseurl]"             string => "url://server1/path/to/repository/";
#       "setrepo[repositoryid][metalink]"            string => "";
#       "setrepo[repositoryid][mirrorlist]"          string => "";
#       "setrepo[repositoryid][enabled]"             string => "";
#       "setrepo[repositoryid][gpgcheck]"            string => "";
#       "setrepo[repositoryid][repo_gpgcheck]"       string => "";
#       "setrepo[repositoryid][gpgkey]"              string => "";
#       "setrepo[repositoryid][gpgcakey]"            string => "";
#       "setrepo[repositoryid][exclude]"             string => "";
#       "setrepo[repositoryid][includepkgs]"         string => "";
#       "setrepo[repositoryid][enablegroups]"        string => "";
#       "setrepo[repositoryid][failovermethod]"      string => "";
#       "setrepo[repositoryid][keepalive]"           string => "";
#       "setrepo[repositoryid][timeout]"             string => "";
#       "setrepo[repositoryid][http_caching]"        string => "";
#       "setrepo[repositoryid][retries]"             string => "";
#       "setrepo[repositoryid][throttle]"            string => "";
#       "setrepo[repositoryid][bandwidth]"           string => "";
#       "setrepo[repositoryid][sslcacert]"           string => "";
#       "setrepo[repositoryid][sslverify]"           string => "";
#       "setrepo[repositoryid][sslclientcert]"       string => "";
#       "setrepo[repositoryid][metadata_expire]"     string => "";
#       "setrepo[repositoryid][mirrorlist_expire]"   string => "";
#       "setrepo[repositoryid][proxy]"               string => "";
#       "setrepo[repositoryid][proxy_username]"      string => "";
#       "setrepo[repositoryid][proxy_password]"      string => "";
#       "setrepo[repositoryid][username]"            string => "";
#       "setrepo[repositoryid][password]"            string => "";
#       "setrepo[repositoryid][cost]"                string => "";
#       "setrepo[repositoryid][skip_if_unavailable]" string => "";
#
#   methods:
#       "any"   usebundle => config_yum_client_repos("context.setrepo");

    vars:
        # Hopefully someday getindices will support multidimensional arrays and we 
        # can get rid of this valid_entries list.
        "valid_entries" slist => { "name", "baseurl", "metalink", "mirrorlist",
                                    "enabled", "gpgcheck", "repo_gpgcheck",
                                    "gpgkey", "gpgcakey", "exclude", 
                                    "includepkgs", "enablegroups", "failovermethod",
                                    "keepalive", "timeout", "http_caching", "retries",
                                    "throttle", "bandwidth", "sslcacert", "sslverify",
                                    "sslclientcert", "metadata_expire", "mirrorlist_expire",
                                    "proxy", "proxy_username", "username", "password", "cost",
                                    "skip_if_unavailable", };
        "repoids" slist => getindices("$(config)");
    
    files:
        "/etc/yum.repos.d/$(repoids).repo"
            create => "true",
            edit_line   => prepend_if_no_line("[$(repoids)]");

        # Using replace_or_add instead of set_variable_values2 here because we
        # need to loop on the second dimension of the array and getindices does
        # not currently support that, we use the valid_entries list instead.
        "/etc/yum.repos.d/$(repoids).repo"
            create => "true",
            edit_line       => replace_or_add("$(valid_entries)=.*", "$(valid_entries)=$($(config)[$(repoids)][$(valid_entries)])"),
            comment         => "Completely manage specific repo settings";

}
