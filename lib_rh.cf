bundle agent rh_add_interface_routes(interface, routes) {
# Expects string, array
# vars:
#    "management[172.18.43.0/24]"
#        string => "172.18.43.0/24 via 10.124.4.254",
#        comment => "Needed for communicating with monitoring cluster";
#
#    "management[10.119.156.0/26]"
#        string => "10.119.156.0/26 via 10.124.4.254",
#        comment => "Needed for talking to management interfaces on legacy
#                   network";
# methods:
#    "any" usebundle => rh_add_routes("bond2", "main.management");
#
    classes:
        "supported_os" or => { "centos_5", "redhat_5" };

    vars:
        "route_file"  string => "/etc/sysconfig/network-scripts/route-$(interface)";
        "route_index" slist => getindices("$(routes)");

    files:
        (centos_5|redhat_5)::
            "$(route_file)"
                comment     => "Ensure routes are added properly",
                create      => "true",
                perms       => mog("644", "root", "root"),
                edit_line   => append_if_no_line("$($(this.routes)[$(route_index)])"),
                classes     => if_repaired("route_add_restart_network");

    commands:
        route_add_restart_network::
            "/etc/init.d/network restart",
                ifvarclass => "centos_5|redhat_5";

    reports:
        !supported_os::
            "Sorry I don't know how to work with this OS";

}

bundle agent create_update_yum_repo(path) {
# Creates repomd (xml-rpm-metadata) repository 
# Updates metadata if any packages are added changed or removed
# Expects full path to repository directory
#    vars:
#        "updates_repo" string => "/var/repo_mirror/updates";
#
#    methods:
#        "supplemental_repo" usebundle => create_update_yum_repo("/var/repo_mirror/supplemental");
#        "updates_repo" usebundle => create_update_yum_repo("$(updates)");


    files:
        "$(path)/."
            create => "true",
            perms  => mog("755", "root", "root"),
            comment => "Ensure repository root directory exists";

        # Only check 1 level deep otherwise you will be detecting the change in the metadata itself as well.
        # That in turn will lead to an execution of creatrepo --update each time.
        "$(path)"
            changes         => detect_content,
            depth_search    => recurse("1"),
            classes         => if_repaired("update_repo_metadata"),
            comment         => "If any changes are detected we need to signal to update the metadata";

    classes:
        "repo_exists"    expression => fileexists("$(path)/repodata/repomd.xml"),
            comment => "Check if a repo exists yet";


    commands:
        "/usr/bin/createrepo $(path)"
            ifvarclass => not("repo_exists"),
            comment => "Create repository if one does not exist";

        # We only want to update the repo once per run. The metadata has not 
        # yet been updated. Update it and signal that it has been updated if 
        # the command returns zero.
        !(repo_metadata_updated)::
        "/usr/bin/createrepo --update $(path)"
            ifvarclass => "update_repo_metadata",
            classes    => if_repaired("repo_metadata_updated"),
            comment    => "We need to update the metadata since a change was detected, but only once per run";


}

bundle agent set_selinux_disabled {
# This bundle disables selinux
# If its currently enabled, it disables it
# It makes sure that it is configured to be disabled on next boot (via config file)
# Note: If enabled currently this just sets it to permissive, so you will have
#       extra logging until the next reboot.
#
    vars:
        "config[SELINUX]"   string  => "disabled";

        # If neither one of these is set, its the first pass, we only need to set this variable once
        !(selinux_disabled|selinux_needs_disabled)::
            "selinux_status"
                string => execresult("/usr/sbin/getenforce", "noshell"),
                policy => "overridable";

    classes:
        "selinux_disabled"  expression => regcmp("Permissive|Disabled", "$(selinux_status)");

        "selinux_needs_disabled" not => "selinux_disabled";
            

    commands:
        # Only set it once
        # If its not disabled, but needs disabled do it and raise a class
        !selinux_disabled::
            "/usr/sbin/setenforce 0"
                classes => "selinux_disabled",
                ifvarclass  => "selinux_needs_disabled",
                comment     => "Disable selinux, it causes issues without proper security
                                contexts and sadly no one wants to spend time on that";
    files:
        "/etc/selinux/config"
            edit_line => set_variable_values2("$(this.promiser)", "set_selinux_disabled.config"),
            comment     => "Make disable persistent across reboot";
}
